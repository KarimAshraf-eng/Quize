{
  "title_en": "Mid General 2025",
  "title_ar": "امتحان الميد للقسم العام 2025",
  "questions": [
    {
      "question_number": 1,
      "lecture_number": 1,
      "question_ar": "تُعد حدود تبديد حرارة المعالج (CPU heat dissipation) دافعًا رئيسيًا لاستخدام الحاسوبية ___.",
      "question_en": "CPU heat dissipation limits are a key motivation for using ___ computing.",
      "choices": {
        "A_ar": "التسلسلية (sequential)",
        "A_en": "sequential",
        "B_ar": "الكمومية (quantum)",
        "B_en": "quantum",
        "C_ar": "المتوازية (parallel)",
        "C_en": "parallel",
        "D_ar": "التناظرية (analog)",
        "D_en": "analog"
      },
      "correct_choice": "C",
      "explanation_correct_ar": "المحاضرة الأولى (صفحة 9) تناقش 'استهلاك طاقة المعالج وتبديد الحرارة'. وتشير صراحة إلى أن 'التوازي (Parallelism) يمكن أن يساعد في الحفاظ على الطاقة'.",
      "explanation_correct_en": "Lecture 1 (page 9) discusses 'CPU Energy Consumption & Heat Dissipation'. It explicitly states that 'Parallelism can help to conserve energy'.",
      "explanation_wrong_ar": {
        "A": "الحاسوبية التسلسلية (استخدام معالج واحد بتردد عالٍ) هي التي تسببت في الوصول إلى هذه الحدود الحرارية، وليست الحل.",
        "B": "لم يُذكر مصطلح 'الحوسبة الكمومية' في أي من المحاضرات الخمس المرفقة.",
        "C": "هذه هي الإجابة الصحيحة.",
        "D": "لم يُذكر مصطلح 'الحوسبة التناظرية' في أي من المحاضرات الخمس المرفقة."
      },
      "explanation_wrong_en": {
        "A": "Sequential computing (using one high-frequency CPU) is what caused these heat limits, not the solution.",
        "B": "The term 'quantum computing' was not mentioned in the provided lectures.",
        "C": "This is the correct answer.",
        "D": "The term 'analog computing' was not mentioned in the provided lectures."
      }
    },
    {
      "question_number": 2,
      "lecture_number": 1,
      "question_ar": "يتم تحقيق التسريع المثالي (Ideal speedup) عندما تكون SP = ___.",
      "question_en": "Ideal speedup is achieved when SP = ___.",
      "choices": {
        "A_ar": "1",
        "A_en": "1",
        "B_ar": "P",
        "B_en": "P",
        "C_ar": "f",
        "C_en": "f",
        "D_ar": "Sf / F",
        "D_en": "Sf / F"
      },
      "correct_choice": "B",
      "explanation_correct_ar": "المحاضرة الأولى (صفحة 14) تنص بوضوح: 'التسريع يكون مثاليًا (perfect or ideal) إذا كانت SP = P'، حيث P تمثل عدد المعالجات.",
      "explanation_correct_en": "Lecture 1 (page 14) explicitly states: 'The speedup is perfect or ideal if SP = P', where P is the number of processors.",
      "explanation_wrong_ar": {
        "A": "تسريع يساوي 1 يعني عدم وجود أي تحسن في الأداء.",
        "B": "هذه هي الإجابة الصحيحة.",
        "C": "الرمز f يُستخدم للإشارة إلى 'الجزء التسلسلي' في قانون أمدال، وهو عامل يحد من التسريع.",
        "D": "هذا الرمز لم يُذكر في المحاضرات بهذا السياق."
      },
      "explanation_wrong_en": {
        "A": "A speedup of 1 means no performance improvement.",
        "B": "This is the correct answer.",
        "C": "The symbol f is used to denote the 'serial fraction' in Amdahl's Law, which limits speedup.",
        "D": "This symbol was not mentioned in the lectures in this context."
      }
    },
    {
      "question_number": 3,
      "lecture_number": 1,
      "question_ar": "قانون جوستافسون (Gustafson's Law) يُبقي ___ ثابتًا أثناء تغيير حجم المشكلة.",
      "question_en": "Gustafson's Law keeps ___ constant while scaling the problem size.",
      "choices": {
        "A_ar": "حمل العمل (workload)",
        "A_en": "workload",
        "B_ar": "الزمن التسلسلي (sequential time)",
        "B_en": "sequential time",
        "C_ar": "الزمن المتوازي (parallel time)",
        "C_en": "parallel time",
        "D_ar": "الكفاءة (efficiency)",
        "D_en": "efficiency"
      },
      "correct_choice": "C",
      "explanation_correct_ar": "المحاضرة الأولى (صفحة 22) تذكر أن قانون جوستافسون 'يُبقي زمن التنفيذ الموازي ثابتًا (keeping the parallel execution time constant)'.",
      "explanation_correct_en": "Lecture 1 (page 22) states that Gustafson's Law 'defines the scaled speedup by keeping the parallel execution time constant'.",
      "explanation_wrong_ar": {
        "A": "قانون أمدال (Amdahl's Law) هو الذي 'يعتمد على حمل عمل ثابت'.",
        "B": "الزمن التسلسلي هو متغير يتم حسابه في معادلة جوستافسون، ولا يتم تثبيته.",
        "C": "هذه هي الإجابة الصحيحة.",
        "D": "الكفاءة هي مقياس يُشتق من التسريع، وليست المتغير الذي يتم تثبيته."
      },
      "explanation_wrong_en": {
        "A": "Amdahl's Law is the one 'based on a fixed workload'.",
        "B": "Sequential time is a calculated variable in Gustafson's law, not the constant.",
        "C": "This is the correct answer.",
        "D": "Efficiency is a derived metric, not the variable that is held constant."
      }
    },
    {
      "question_number": 4,
      "lecture_number": 1,
      "question_ar": "ضعف الموضعية (Poor locality) في الوصول للذاكرة يؤدي إلى قيود في الأداء تُعرف بـ ___.",
      "question_en": "Poor locality in memory access leads to performance limits known as the ___ wall.",
      "choices": {
        "A_ar": "جدار البيانات (data)",
        "A_en": "data",
        "B_ar": "جدار الذاكرة (memory)",
        "B_en": "memory",
        "C_ar": "جدار خط الأنابيب (pipeline)",
        "C_en": "pipeline",
        "D_ar": "جدار الذاكرة المخبئية (cache)",
        "D_en": "cache"
      },
      "correct_choice": "B",
      "explanation_correct_ar": "المحاضرة الأولى (صفحة 29) تذكر صراحة: 'جدار الذاكرة (Memory wall) يشير إلى التفاوت المتزايد في السرعة بين المعالج (CPU) والذاكرة خارج شريحة المعالج'.",
      "explanation_correct_en": "Lecture 1 (page 29) explicitly states: 'The Memory wall refers to the growing disparity of speed between CPU and memory outside the CPU chip'.",
      "explanation_wrong_ar": {
        "A": "لم يُذكر هذا المصطلح في المحاضرات.",
        "B": "هذه هي الإجابة الصحيحة.",
        "C": "لم يُذكر هذا المصطلح في المحاضرات.",
        "D": "لم يُذكر هذا المصطلح في المحاضرات."
      },
      "explanation_wrong_en": {
        "A": "This term was not mentioned in the lectures.",
        "B": "This is the correct answer.",
        "C": "This term was not mentioned in the lectures.",
        "D": "This term was not mentioned in the lectures."
      }
    },
    {
      "question_number": 5,
      "lecture_number": 2,
      "question_ar": "المعالجات فائقة القياس (N-way superscalar processors) تجلب ___ تعليمات كل دورة.",
      "question_en": "N-way superscalar processors fetch ___ instructions each cycle.",
      "choices": {
        "A_ar": "واحدة (one)",
        "A_en": "one",
        "B_ar": "متعددة (multiple)",
        "B_en": "multiple",
        "C_ar": "شرطية (conditional)",
        "C_en": "conditional",
        "D_ar": "تخمينية (speculative)",
        "D_en": "speculative"
      },
      "correct_choice": "B",
      "explanation_correct_ar": "المحاضرة الثانية (صفحة 9) تصف المعالجات 'N-way superscalar' بأنها 'تجلب N من التعليمات (fetch N instructions) كل دورة'، و N تشير إلى عدد متعدد.",
      "explanation_correct_en": "Lecture 2 (page 9) describes 'N-way superscalar' processors as those that 'fetch N instructions each cycle', where N implies a multiple number.",
      "explanation_wrong_ar": {
        "A": "جلب تعليمة واحدة هو السلوك القياسي لخط الأنابيب البسيط، وليس لـ superscalar.",
        "B": "هذه هي الإجابة الصحيحة.",
        "C": "'الشرطية' تصف نوعًا من التعليمات، وليست كمية التعليمات.",
        "D": "'التخمينية' تصف آلية لتنفيذ التعليمات، وليست كمية التعليمات."
      },
      "explanation_wrong_en": {
        "A": "Fetching one instruction is standard pipelining, not superscalar.",
        "B": "This is the correct answer.",
        "C": "'Conditional' describes a type of instruction, not the quantity.",
        "D": "'Speculative' describes a mechanism for execution, not the quantity."
      }
    },
    {
      "question_number": 6,
      "lecture_number": 2,
      "question_ar": "آلية إعادة تسمية السجلات (Register renaming) تزيل اعتماديات ___ غير الضرورية.",
      "question_en": "Register renaming removes unnecessary ___ dependencies.",
      "choices": {
        "A_ar": "RAW",
        "A_en": "RAW",
        "B_ar": "WAR",
        "B_en": "WAR",
        "C_ar": "WAW",
        "C_en": "WAW",
        "D_ar": "temporal",
        "D_en": "temporal"
      },
      "correct_choice": "B",
      "explanation_correct_ar": "المحاضرة الثانية (صفحة 22) تذكر صراحة أن 'إعادة تسمية السجلات ... تزيل اعتماديات WAR (Write-After-Read) غير الضرورية الناتجة عن إعادة استخدام السجلات'.",
      "explanation_correct_en": "Lecture 2 (page 22) explicitly states that 'Register renaming ... removes unnecessary WAR dependences caused by register reuse'.",
      "explanation_wrong_ar": {
        "A": "اعتمادية RAW هي 'اعتمادية حقيقية (true dependence)' ولا يمكن إزالتها.",
        "B": "هذه هي الإجابة الصحيحة.",
        "C": "اعتمادية WAW هي أيضًا 'اعتمادية زائفة' يمكن إزالتها، ولكن المحاضرة ركزت على WAR.",
        "D": "'الزمانية' تصف 'الموضعية الزمانية'، وليست نوعًا من اعتماديات البيانات."
      },
      "explanation_wrong_en": {
        "A": "RAW is a 'true dependence' and cannot be removed.",
        "B": "This is the correct answer.",
        "C": "WAW is also a 'false dependence' that can be removed, but the lecture highlighted WAR.",
        "D": "'Temporal' describes 'Temporal locality', not a type of data dependency."
      }
    },
    {
      "question_number": 7,
      "lecture_number": 2,
      "question_ar": "التكهن بالتحكم (Control speculation) ينفذ التعليمات الشرطية ___ الفرع (branch).",
      "question_en": "Control speculation executes conditional instructions ___ the branch.",
      "choices": {
        "A_ar": "بعد (after)",
        "A_en": "after",
        "B_ar": "قبل (before)",
        "B_en": "before",
        "C_ar": "ضمن (within)",
        "C_en": "within",
        "D_ar": "خارج (outside)",
        "D_en": "outside"
      },
      "correct_choice": "B",
      "explanation_correct_ar": "المحاضرة الثانية (صفحة 24) تعرّف 'التكهن بالتحكم' بأنه 'يسمح للتعليمات الشرطية بأن تُنفذ قبل (before) فرع التحكم (conditional branch)'.",
      "explanation_correct_en": "Lecture 2 (page 24) defines 'Control speculation' as allowing 'conditional instructions to be executed before the conditional branch'.",
      "explanation_wrong_ar": {
        "A": "التنفيذ 'بعد' الفرع هو السلوك الطبيعي إذا لم يتم اتخاذ الفرع.",
        "B": "هذه هي الإجابة الصحيحة.",
        "C": "مصطلح غامض ولا يصف المفهوم.",
        "D": "مصطلح غامض ولا يصف المفهوم."
      },
      "explanation_wrong_en": {
        "A": "Executing 'after' the branch is the normal behavior if the branch isn't taken.",
        "B": "This is the correct answer.",
        "C": "Vague term that doesn't describe the concept.",
        "D": "Vague term that doesn't describe the concept."
      }
    },
    {
      "question_number": 8,
      "lecture_number": 2,
      "question_ar": "إخفاقات ذاكرة التخزين المؤقت (Cache misses) لها ثلاثة أنواع رئيسية: إجبارية (compulsory)، وسعة (capacity)، و ___.",
      "question_en": "Cache misses are of three main types: compulsory, capacity, and ___.",
      "choices": {
        "A_ar": "سجل (register)",
        "A_en": "register",
        "B_ar": "تماسك (coherence)",
        "B_en": "coherence",
        "C_ar": "تعارض (conflict)",
        "C_en": "conflict",
        "D_ar": "تسلسلي (sequential)",
        "D_en": "sequential"
      },
      "correct_choice": "C",
      "explanation_correct_ar": "المحاضرة الثانية (صفحة 34) تعدد صراحة الأنواع الثلاثة: Compulsory, Capacity, و Conflict misses.",
      "explanation_correct_en": "Lecture 2 (page 34) explicitly lists the three types: Compulsory, Capacity, and Conflict misses.",
      "explanation_wrong_ar": {
        "A": "السجلات هي مستوى أعلى من ذاكرة التخزين المؤقت، وليست نوعًا من إخفاقاتها.",
        "B": "'التماسك' هو بروتوكول، ومشاكله تسبب 'False Sharing'، لكنه ليس نوعًا من الإخفاق.",
        "C": "هذه هي الإجابة الصحيحة.",
        "D": "لم يُذكر هذا المصطلح كنوع من إخفاقات ذاكرة التخزين المؤقت."
      },
      "explanation_wrong_en": {
        "A": "Registers are a level above cache, not a type of miss.",
        "B": "'Coherence' is a protocol; its issues cause 'False Sharing', but it's not a miss type.",
        "C": "This is the correct answer.",
        "D": "This term was not mentioned as a type of cache miss."
      }
    },
    {
      "question_number": 9,
      "lecture_number": 3,
      "question_ar": "تُعرف المعالجات المتعددة ذات الذاكرة المشتركة (Shared memory multiprocessors) أيضًا باسم ___.",
      "question_en": "Shared memory multiprocessors are also known as ___.",
      "choices": {
        "A_ar": "MPP",
        "A_en": "MPP",
        "B_ar": "NUMA",
        "B_en": "NUMA",
        "C_ar": "SMP",
        "C_en": "SMP",
        "D_ar": "COMA",
        "D_en": "COMA"
      },
      "correct_choice": "C",
      "explanation_correct_ar": "المحاضرة الثالثة (صفحة 4) تذكر صراحة أن هذه البنية 'تُعرف أحيانًا باسم \"المعالجات المتعددة المتماثلة - SMP\"'.",
      "explanation_correct_en": "Lecture 3 (page 4) explicitly states this architecture is 'sometimes known as a \"Symmetric Multiprocessors - SMP\"'.",
      "explanation_wrong_ar": {
        "A": "MPP يُستخدم لوصف أنظمة الذاكرة الموزعة (صفحة 10).",
        "B": "NUMA هو نوع من الوصول للذاكرة، وليس مرادفًا لـ SMP.",
        "C": "هذه هي الإجابة الصحيحة.",
        "D": "COMA هو نوع محدد من أبنية الذاكرة المخبئية (صفحة 9)."
      },
      "explanation_wrong_en": {
        "A": "MPP is used for Distributed Memory systems (page 10).",
        "B": "NUMA is a type of memory access, not synonymous with SMP.",
        "C": "This is the correct answer.",
        "D": "COMA is a specific cache-only architecture (page 9)."
      }
    },
    {
      "question_number": 10,
      "lecture_number": 3,
      "question_ar": "نسبة عمليات الفاصلة العائمة (floating-point operations) إلى عمليات الوصول المميزة للذاكرة (distinct memory accesses) هي نسبة ___.",
      "question_en": "The ratio of floating-point operations to distinct memory accesses is the ___ ratio.",
      "choices": {
        "A_ar": "عرض النطاق (bandwidth)",
        "A_en": "bandwidth",
        "B_ar": "FP:M",
        "B_en": "FP:M",
        "C_ar": "I/O (الإدخال/الإخراج)",
        "C_en": "I/O",
        "D_ar": "W/F",
        "D_en": "W/F"
      },
      "correct_choice": "B",
      "explanation_correct_ar": "المحاضرة الثالثة (صفحة 6) تعرّف 'نسبة العمل إلى الذاكرة' وتطلق عليها اسم 'نسبة FP:M (FP:M ratio)'.",
      "explanation_correct_en": "Lecture 3 (page 6) defines the 'Work-memory ratio' and calls it the 'FP:M ratio'.",
      "explanation_wrong_ar": {
        "A": "لم يُعرّف عرض النطاق بهذه النسبة.",
        "B": "هذه هي الإجابة الصحيحة.",
        "C": "هذا المصطلح يشير إلى الإدخال والإخراج.",
        "D": "هذه النسبة (W/F) ذُكرت في (صفحة 5) لكنها تشير إلى نسبة 'الكلمات (Words)' إلى 'التعليمات (F instructions)'."
      },
      "explanation_wrong_en": {
        "A": "Bandwidth is not defined by this ratio.",
        "B": "This is the correct answer.",
        "C": "This term refers to Input/Output.",
        "D": "This ratio (W/F) was mentioned (page 5) but refers to 'Words (W)' to 'Instructions (F)'."
      }
    },
    {
      "question_number": 11,
      "lecture_number": 4,
      "question_ar": "التنميط القائم على الأدوات (Instrumentation-based profiling) يضيف:",
      "question_en": "Instrumentation-based profiling adds:",
      "choices": {
        "A_ar": "عدادات (Counters)",
        "A_en": "Counters",
        "B_ar": "سجلات (Logs)",
        "B_en": "Logs",
        "C_ar": "نقاط توقف (Breakpoints)",
        "C_en": "Breakpoints",
        "D_ar": "خيوط (Threads)",
        "D_en": "Threads"
      },
      "correct_choice": "A",
      "explanation_correct_ar": "المحاضرة الرابعة (صفحة 10) تصف هذا النوع من التنميط بأنه 'يضيف أدوات للكود لتسجيل الأحداث، عادةً باستخدام عدادات (counters)'.",
      "explanation_correct_en": "Lecture 4 (page 10) describes this type of profiling as 'Instruments code to record events, usually with counters'.",
      "explanation_wrong_ar": {
        "A": "هذه هي الإجابة الصحيحة.",
        "B": "'العدادات' هي الأداة المحددة المضافة للكود، وليس 'السجلات' بشكل عام.",
        "C": "نقاط التوقف تُستخدم في مصححات الأخطاء، وليست في التنميط.",
        "D": "الخيوط هي جزء من البرنامج، وليست أداة يضيفها المنمّط."
      },
      "explanation_wrong_en": {
        "A": "This is the correct answer.",
        "B": "'Counters' are the specific tool added, not 'Logs' in general.",
        "C": "Breakpoints are used in debuggers, not profiling.",
        "D": "Threads are part of the program, not a tool added by the profiler."
      }
    },
    {
      "question_number": 12,
      "lecture_number": 4,
      "question_ar": "تحدث 'أخطاء هايزنبرج (Heisenbugs)' بسبب:",
      "question_en": "Heisenbugs occur due to:",
      "choices": {
        "A_ar": "تسريب الذاكرة (Memory leaks)",
        "A_en": "Memory leaks",
        "B_ar": "تغيرات التوقيت (Timing changes)",
        "B_en": "Timing changes",
        "C_ar": "أخطاء الصياغة (Syntax errors)",
        "C_en": "Syntax errors",
        "D_ar": "أخطاء المترجم (Compiler bugs)",
        "D_en": "Compiler bugs"
      },
      "correct_choice": "B",
      "explanation_correct_ar": "المحاضرة الرابعة (صفحة 11) تشرح أن 'Heisenbugs' تحدث 'عندما يؤدي التنميط ... إلى تغيير وقت التشغيل (changes the running time)'، مما 'يغير التوقيت الداخلي (internal timing) للأحداث'.",
      "explanation_correct_en": "Lecture 4 (page 11) explains 'Heisenbugs' occur 'when profiling ... that changes the running time', which 'changes the internal timing of events'.",
      "explanation_wrong_ar": {
        "A": "المحاضرة لم تربط 'Heisenbugs' بتسريب الذاكرة.",
        "B": "هذه هي الإجابة الصحيحة.",
        "C": "أخطاء الصياغة يتم اكتشافها بواسطة المترجم قبل تشغيل البرنامج.",
        "D": "المحاضرة تعزو 'Heisenbugs' إلى تأثير أداة التنميط، وليس خطأ في المترجم."
      },
      "explanation_wrong_en": {
        "A": "The lecture does not link 'Heisenbugs' to memory leaks.",
        "B": "This is the correct answer.",
        "C": "Syntax errors are caught by the compiler before the program runs.",
        "D": "The lecture attributes 'Heisenbugs' to the profiler's effect, not a compiler bug."
      }
    }
  ]
}